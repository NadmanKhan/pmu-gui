#ifndef QPMU_COMMON_H
#define QPMU_COMMON_H

#include <array>
#include <cstddef>
#include <cstdint>
#include <complex>
#include <string>

namespace qpmu {

constexpr auto OrgName = PROJECT_ORG_NAME;
constexpr auto AppName = PROJECT_APP_NAME;
constexpr auto AppDisplayName = PROJECT_APP_NAME;

using FloatType = FLOAT_TYPE;
using Complex = std::complex<FloatType>;
using USize = std::size_t;
using U64 = std::uint64_t;
using U32 = std::uint16_t;
using U16 = std::uint16_t;
using ISize = ssize_t;
using I64 = std::int64_t;
using I32 = std::int16_t;
using I16 = std::int16_t;

/// Voltage, Current
constexpr USize CountSignalTypes = 2;

/// A, B, C
constexpr USize CountSignalPhases = 3;

/// 3 phases * 2 types = 6 channels
constexpr USize CountSignals = CountSignalPhases * CountSignalTypes;

/// V for Voltage, I for Current
constexpr char SignalTypeNames[CountSignalTypes] = { 'V', 'I' };

/// A, B, C
constexpr char SignalPhaseNames[CountSignalPhases] = { 'A', 'B', 'C' };

/// { { VA, IA }, { VB, IB }, { VC, IC } }
constexpr std::array<std::pair<USize, USize>, CountSignalPhases> SignalPhasePairs = {
    { { 0, 3 }, { 1, 4 }, { 2, 5 } }
};

/// V for Volts, A for Amperes
constexpr char SignalTypeUnit[CountSignalTypes] = { 'V', 'A' };

/// Number of fields in a sample generated by the Analog-to-Digital Converter (ADC) driver
constexpr USize CountSampleFields = 9;

/// Names of fields in a sample generated by the Analog-to-Digital Converter (ADC) driver
constexpr char const *SampleFieldNames[CountSampleFields] = {
    "Sequence number", "VA", "VB", "VC", "IA", "IB", "IC", "Timestamp (µs)", "Time-delta (µs)"
};

/// Types of fields in a sample generated by the Analog-to-Digital Converter (ADC) driver
enum class SampleField {

    /// Sequence number (e.g., 1, 2, 3, ...)
    /// to identify a sample
    SequenceNumber = 0,

    /// Voltage of phase A
    VA,

    /// Voltage of phase B
    VB,

    /// Voltage of phase C
    VC,

    /// Current of phase A
    IA,

    /// Current of phase B
    IB,

    /// Current of phase C
    IC,

    /// Timestamp (in microseconds)
    Timestamp,

    /// Time difference from the previous sample (in microseconds)
    TimeDelta
};

/// Shape (i.e. field order) of a sample generated by the Analog-to-Digital Converter (ADC) driver
using SampleFieldOrdering = std::array<SampleField, CountSampleFields>;

/// Sample generated by the Analog-to-Digital Converter (ADC) driver
struct Sample
{
    /// Sequence number
    U64 seq_no;

    /// Channel values
    std::array<U64, CountSignals> ch;

    /// Timestamp (in microseconds)
    U64 ts;

    /// Timestamp difference from previous sample (in microseconds)
    U64 delta;
};

struct SampleSourceConfig
{
    /// Source type
    enum class Type { Stdin, Tcp, Udp, File, Process } type;

    /// Data to connect to the source
    union Handle {
        /// Standard input
        std::nullptr_t null;

        /// TCP or UDP socket
        struct Socket
        {
            /// Hostname or IP address
            char const *host;

            /// Port number
            unsigned short port;
        } socket;

        /// Process or file
        struct File
        {
            /// Path to the executable or file
            char const *path;

            /// Arguments to the executable
            char const *args;
        } file;

    } handle;

    /// Is the data in binary or text format?
    bool format_is_binary;
};

struct SignalConfig
{
    /// Signal index
    USize index;

    /// Signal name ("VA", "VB", "VC", "IA", "IB", "IC")
    char const *name;

    /// Signal type (Voltage or Current)
    enum class Type { Voltage, Current } type;

    /// Signal phase (A, B, or C)
    enum class Phase { A, B, C } phase;

    /// Signal color in hexadecimal format, e.g., "#ff0000"
    char const *color;

    /// Calibration factor, i.e., the factor by which the raw ADC value is to be multiplied
    FloatType calib_factor = 1.0;

    /// Calibration offset, i.e., the value to be added to the ADC value after multiplying by the
    /// calibration factor
    FloatType calib_offset = 0.0;
};

/// Estimation of phasors, frequency, and rate of change of frequency
struct Synchrophasor
{
    /// Timestamp (in microseconds)
    U64 timestamp_us;

    /// Phasor magnitudes
    std::array<FloatType, CountSignals> phasor_mag;

    /// Phasor angles (in radians)
    FloatType phasor_ang[CountSignals];

    /// Frequency (in Hz)
    FloatType freq;

    /// Rate of change of frequency (in Hz/s)
    FloatType rocof;
};

// -----------------------------------------------------------------------------------------------

namespace conf {

/// Sampling frequency (in Hz), i.e., number of samples generated per second
constexpr USize SamplingFrequency = 1200;

/// Nominal frequency of the power system (in Hz)
constexpr USize NominalFrequency = 50;

static_assert(SamplingFrequency % NominalFrequency == 0,
              "Sampling frequency must be a multiple of the nominal frequency");

/// Source of samples
const SampleSourceConfig SampleSourceConfig = { SampleSourceConfig::Type::Stdin,
                                                { nullptr },
                                                true };

/// Signal configurations
constexpr SignalConfig SignalConfigs[CountSignals] = {
    { 0, "VA", SignalConfig::Type::Voltage, SignalConfig::Phase::A, "#404040", 1.0, 0.0 },
    { 1, "VB", SignalConfig::Type::Voltage, SignalConfig::Phase::B, "#ff0000", 1.0, 0.0 },
    { 2, "VC", SignalConfig::Type::Voltage, SignalConfig::Phase::C, "#00ffff", 1.0, 0.0 },
    { 3, "IA", SignalConfig::Type::Current, SignalConfig::Phase::A, "#f1dd38", 1.0, 0.0 },
    { 4, "IB", SignalConfig::Type::Current, SignalConfig::Phase::B, "#0000ff", 1.0, 0.0 },
    { 5, "IC", SignalConfig::Type::Current, SignalConfig::Phase::C, "#22bb45", 1.0, 0.0 }
};

/// Order of fields in a sample generated by the ADC driver
constexpr SampleFieldOrdering SampleFieldOrdering = { SampleField::SequenceNumber,
                                                      SampleField::VA,
                                                      SampleField::VB,
                                                      SampleField::VC,
                                                      SampleField::IA,
                                                      SampleField::IB,
                                                      SampleField::IC,
                                                      SampleField::Timestamp,
                                                      SampleField::TimeDelta };

} // namespace conf

// -----------------------------------------------------------------------------------------------

namespace util {

std::string phasor_to_string(const Complex &phasor);

std::string phasor_polar_to_string(const Complex &phasor);

std::string csv_header_for_synchrophasor();

std::string to_csv(const Synchrophasor &synchrophasor);

std::string to_string(const Synchrophasor &synchrophasor);

bool parse_as_sample(Sample &out_sample, const char *const s,
                     const SampleFieldOrdering &shape = conf::SampleFieldOrdering);

std::string csv_header_for_sample();

std::string to_csv(const Sample &sample);

std::string to_string(const Sample &sample);

} // namespace util
} // namespace qpmu

#endif // QPMU_COMMON_H